//! Exercise 4: Pin and Future Combinators
//!
//! This exercise teaches why `Pin` exists and how to build future combinators
//! that compose smaller futures into larger ones — the building blocks of
//! async libraries like `tokio`, `tower`, and `hyper`.
//!
//! Key concepts:
//! - Why futures that hold references across `.await` are self-referential
//! - `Pin<&mut Self>` guarantees the future won't move between polls
//! - `Unpin` types can be freely moved even when pinned (most leaf types)
//! - `pin-project-lite` provides safe field projection for pinned structs
//! - Combinators compose futures: `Map`, `Timeout`, `Race` are standard patterns
//!
//! # Why not just use async/await?
//!
//! The compiler generates combinators automatically when you write async/await.
//! But libraries like `tower::Service`, `hyper::Body`, and `futures::Stream`
//! require hand-written `Future` implementations for performance and flexibility.
//! Understanding Pin and projection is prerequisite to contributing to these crates.

use pin_project_lite::pin_project;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// ─── Exercise 4a: Map combinator ────────────────────────────────────

pin_project! {
    /// A future combinator that transforms the output of an inner future.
    ///
    /// `Map<Fut, F>` wraps a future `Fut` and a closure `F: FnOnce(Fut::Output) -> T`.
    /// When the inner future completes with value `v`, Map applies `f(v)` and returns
    /// the transformed value.
    ///
    /// This is the hand-written equivalent of:
    /// ```ignore
    /// async { f(inner.await) }
    /// ```
    ///
    /// # Pin projection with pin_project!
    ///
    /// The `#[pin]` attribute on `future` means:
    /// - `future` is pinned when `Map` is pinned (structural pinning)
    /// - You access it as `Pin<&mut Fut>` through the projection
    /// - It must NOT be moved out of the struct
    ///
    /// The `f` field is NOT pinned (no `#[pin]`):
    /// - You get a plain `&mut Option<F>` through the projection
    /// - It CAN be moved (taken) out of the struct
    ///
    /// # Why Option<F>?
    ///
    /// `F: FnOnce` can only be called once, but `poll` is called multiple times.
    /// We wrap `f` in `Option` so we can `.take()` it exactly once when the inner
    /// future completes. After that, `f` is `None` and the Map is in a terminal state.
    pub struct Map<Fut, F> {
        #[pin]
        future: Fut,
        f: Option<F>,
    }
}

impl<Fut, F, T> Map<Fut, F>
where
    Fut: Future,
    F: FnOnce(Fut::Output) -> T,
{
    pub fn new(future: Fut, f: F) -> Self {
        Self {
            future,
            f: Some(f),
        }
    }
}

impl<Fut, F, T> Future for Map<Fut, F>
where
    Fut: Future,
    F: FnOnce(Fut::Output) -> T,
{
    type Output = T;

    /// Poll the Map combinator.
    ///
    /// # TODO(human): Implement the poll logic using pin projection
    ///
    /// Steps:
    ///
    /// 1. Get the projection: `let this = self.project();`
    ///    - `this.future` is `Pin<&mut Fut>` (pinned projection)
    ///    - `this.f` is `&mut Option<F>` (unpinned projection)
    ///
    /// 2. Poll the inner future: `this.future.poll(cx)`
    ///    - If `Pending` → return `Pending` (propagate)
    ///    - If `Ready(output)` → continue to step 3
    ///
    /// 3. Take the closure: `this.f.take().expect("Map polled after completion")`
    ///    - If `f` is `None`, the future was already completed — panic
    ///
    /// 4. Apply the closure: `let result = f(output);`
    ///
    /// 5. Return `Poll::Ready(result)`
    ///
    /// # Why `self.project()`?
    ///
    /// `self` is `Pin<&mut Map<Fut, F>>`. You can't directly access fields because
    /// moving data out of a Pin is unsafe (it could invalidate self-references).
    /// `project()` (generated by pin_project!) gives you safe access to each field
    /// with the correct pin status:
    /// - `#[pin]` fields → `Pin<&mut Field>` (safe to poll, can't be moved)
    /// - non-pin fields → `&mut Field` (can be moved/taken)
    ///
    /// Without pin_project!, you'd need `unsafe { Pin::map_unchecked_mut(...) }`.
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // TODO(human): Implement Map::poll using pin projection.
        //
        // let this = self.project();
        // let output = match this.future.poll(cx) {
        //     Poll::Ready(v) => v,
        //     Poll::Pending => return Poll::Pending,
        // };
        // let f = this.f.take().expect("Map polled after completion");
        // Poll::Ready(f(output))
        todo!("Exercise 4a: Implement Map::poll with pin projection")
    }
}

// ─── Exercise 4b: Race combinator ───────────────────────────────────

pin_project! {
    /// A future combinator that races two futures, returning the output of
    /// whichever completes first.
    ///
    /// This is the hand-written equivalent of `tokio::select!` for two branches,
    /// or `futures::future::select`.
    ///
    /// Both inner futures are `#[pin]` because both may be self-referential
    /// (they're arbitrary futures that might contain async state machines).
    ///
    /// When one future completes, the other is DROPPED. This is async cancellation:
    /// dropping a future stops it at whatever `.await` point it was suspended at.
    /// Destructors run, but no further progress is made.
    pub struct Race<A, B> {
        #[pin]
        a: Option<A>,
        #[pin]
        b: Option<B>,
    }
}

/// Which future won the race.
#[derive(Debug, PartialEq)]
pub enum RaceResult<A, B> {
    Left(A),
    Right(B),
}

impl<A, B> Race<A, B>
where
    A: Future,
    B: Future,
{
    pub fn new(a: A, b: B) -> Self {
        Self {
            a: Some(a),
            b: Some(b),
        }
    }
}

impl<A, B> Future for Race<A, B>
where
    A: Future,
    B: Future,
{
    type Output = RaceResult<A::Output, B::Output>;

    /// Poll the Race combinator.
    ///
    /// # TODO(human): Implement the race poll logic
    ///
    /// Steps:
    ///
    /// 1. Get the projection: `let this = self.project();`
    ///
    /// 2. Poll future `a` (if it hasn't been cancelled yet):
    ///    - Use `this.a.as_pin_mut()` to get `Option<Pin<&mut A>>`.
    ///    - If `Some(pinned_a)`, poll it. If `Ready(val)`:
    ///      a) Set `this.a` to `None` (mark as done).
    ///      b) Set `this.b` to `None` (cancel the loser — this drops it).
    ///      c) Return `Poll::Ready(RaceResult::Left(val))`.
    ///
    /// 3. Poll future `b` (same pattern, returning `RaceResult::Right`).
    ///
    /// 4. If both returned `Pending`, return `Pending`.
    ///
    /// 5. If both are `None` (already completed), panic: "Race polled after completion".
    ///
    /// # Setting a pinned Option to None
    ///
    /// `this.a` is `Pin<&mut Option<A>>`. To set it to None, use:
    /// ```ignore
    /// this.a.set(None);
    /// ```
    /// This is safe because `Option<A>` implements `Unpin` when `A: Unpin`, but
    /// `pin_project!` uses structural pinning. The `set` method on `Pin<&mut Option<T>>`
    /// replaces the value in-place, running the destructor of the old value.
    ///
    /// # Fairness
    ///
    /// This implementation always polls `a` first, giving it priority. A fair
    /// implementation would alternate which future is polled first (e.g., using
    /// a boolean flag). Tokio's `select!` macro randomizes the order.
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // TODO(human): Implement Race::poll.
        //
        // let this = self.project();
        //
        // // Poll A
        // if let Some(a) = this.a.as_pin_mut() {
        //     if let Poll::Ready(val) = a.poll(cx) {
        //         this.a.set(None);
        //         this.b.set(None); // cancel B
        //         return Poll::Ready(RaceResult::Left(val));
        //     }
        // }
        //
        // // Poll B
        // if let Some(b) = this.b.as_pin_mut() {
        //     if let Poll::Ready(val) = b.poll(cx) {
        //         this.a.set(None); // cancel A
        //         this.b.set(None);
        //         return Poll::Ready(RaceResult::Right(val));
        //     }
        // }
        //
        // // Both pending (or one already None but the other is pending)
        // if this.a.as_pin_mut().is_none() && this.b.as_pin_mut().is_none() {
        //     panic!("Race polled after completion");
        // }
        //
        // Poll::Pending
        todo!("Exercise 4b: Implement Race::poll with pin projection")
    }
}

// ─── Exercise 4c: Understanding Unpin ───────────────────────────────

/// Demonstrate that `Unpin` types can be moved freely even under Pin.
///
/// # TODO(human): Complete the demonstration
///
/// This function shows that for `Unpin` types (integers, strings, plain structs),
/// `Pin` is a no-op — you can get `&mut T` from `Pin<&mut T>` via `get_mut()`.
///
/// But for `!Unpin` types (compiler-generated async state machines), `Pin`
/// enforces the no-move guarantee. You CANNOT get `&mut T` from `Pin<&mut T>`
/// without unsafe code.
///
/// Steps:
///
/// 1. Create a `Pin<Box<i32>>` using `Box::pin(42)`.
/// 2. Since i32 is `Unpin`, you can get `&mut i32` via `pin.as_mut().get_mut()`.
/// 3. Modify the value through the mutable reference.
/// 4. Print the new value.
///
/// 5. Create an `async {}` block (this is `!Unpin`).
/// 6. Pin it with `Box::pin(async { 42 })`.
/// 7. Note: you CANNOT call `get_mut()` on this — it won't compile.
///    Comment this out and add a note explaining why.
/// 8. You CAN poll it via `as_mut().poll(cx)` — that's the whole point of Pin.
///
/// # Key insight
///
/// Pin exists to protect self-referential types (async state machines).
/// For non-self-referential types (Unpin), Pin is transparent. The type system
/// ensures you never accidentally move a self-referential future.
pub fn demonstrate_unpin() {
    // TODO(human): Show that Unpin types can be freely accessed through Pin,
    // while !Unpin types (async blocks) cannot be moved out of Pin.
    //
    // Part 1: Pin<Box<i32>> — i32 is Unpin
    //   let mut pinned = Box::pin(42i32);
    //   *pinned.as_mut().get_mut() = 99;  // This works! i32 is Unpin.
    //   println!("  Pinned i32 (Unpin): {}", *pinned);
    //
    // Part 2: Pin<Box<async block>> — async blocks are !Unpin
    //   let pinned_future = Box::pin(async { 42 });
    //   // DOES NOT COMPILE: pinned_future.as_mut().get_mut()
    //   // Error: "the trait `Unpin` is not implemented for `impl Future`"
    //   println!("  Async blocks are !Unpin — can only be polled through Pin, not moved out.");
    //
    // This distinction is what makes the entire Future/Pin system work.
    todo!("Exercise 4c: Demonstrate Unpin vs !Unpin behavior")
}

// ─── Demo runner ────────────────────────────────────────────────────

/// Helper: block_on with a no-op waker (same as Exercise 1).
fn block_on_simple<F: Future + Unpin>(mut future: F) -> F::Output {
    use std::task::{RawWaker, RawWakerVTable, Waker};
    fn no_op(_: *const ()) {}
    fn clone(ptr: *const ()) -> RawWaker {
        RawWaker::new(ptr, &VTABLE)
    }
    static VTABLE: RawWakerVTable = RawWakerVTable::new(clone, no_op, no_op, no_op);
    let raw = RawWaker::new(std::ptr::null(), &VTABLE);
    let waker = unsafe { Waker::from_raw(raw) };
    let mut cx = Context::from_waker(&waker);
    loop {
        match Pin::new(&mut future).poll(&mut cx) {
            Poll::Ready(output) => return output,
            Poll::Pending => continue,
        }
    }
}

pub fn run() {
    use crate::ex1_manual_future::{Countdown, Ready};

    println!("--- 4a: Map combinator ---");
    let mapped = Map::new(Ready::new(10), |x| x * 3);
    let result = block_on_simple(mapped);
    println!("  Map(Ready(10), |x| x*3) = {}", result);
    println!();

    println!("--- 4b: Race combinator ---");
    // Countdown(2) takes 2 polls; Countdown(5) takes 5 polls.
    // Race should complete when the shorter one finishes first.
    let race = Race::new(Countdown::new(2), Countdown::new(5));
    let result = block_on_simple(race);
    println!("  Race(Countdown(2), Countdown(5)) = {:?}", result);
    println!("  (Left wins because it completes in fewer polls)\n");

    println!("--- 4c: Unpin demonstration ---");
    demonstrate_unpin();
}

// ─── Tests ──────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ex1_manual_future::{Countdown, Ready};

    #[test]
    fn map_transforms_output() {
        let mapped = Map::new(Ready::new(7), |x| x + 3);
        assert_eq!(block_on_simple(mapped), 10);
    }

    #[test]
    fn map_works_with_string() {
        let mapped = Map::new(Ready::new("hello"), |s: &str| s.len());
        assert_eq!(block_on_simple(mapped), 5);
    }

    #[test]
    fn race_left_wins_when_faster() {
        let race = Race::new(Ready::new(1), Countdown::new(5));
        let result = block_on_simple(race);
        assert_eq!(result, RaceResult::Left(1));
    }

    #[test]
    fn race_right_wins_when_left_is_slower() {
        // Countdown(3) takes 3 polls to complete (returns () at poll 4).
        // Ready(42) completes on first poll.
        // Since we poll A first, and A (Countdown) returns Pending,
        // then we poll B (Ready) which returns Ready(42).
        let race = Race::new(Countdown::new(3), Ready::new(42));
        let result = block_on_simple(race);
        assert_eq!(result, RaceResult::Right(42));
    }
}
