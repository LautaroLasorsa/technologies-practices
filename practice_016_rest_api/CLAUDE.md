# Practice 016: REST API Design Principles

## Technologies

- **FastAPI** — Modern Python web framework with automatic OpenAPI generation
- **Pydantic v2** — Data validation and serialization via Python type hints
- **OpenAPI 3.1** — API specification standard (auto-generated by FastAPI)
- **RFC 9457 / RFC 7807** — Problem Details for HTTP APIs (structured error responses)
- **HATEOAS** — Hypermedia as the Engine of Application State

## Stack

- Python 3.12+ (uv)

## Theoretical Context

### REST: Architectural Constraints for Scalable Web Services

REST (Representational State Transfer) is an architectural style defined by Roy Fielding in his 2000 PhD dissertation. REST prescribes six constraints: **client-server** (separation of UI from data storage), **stateless** (each request contains all information needed; no session state on server), **cacheable** (responses must declare cacheability), **uniform interface** (standardized communication via URIs, HTTP methods, and hypermedia), **layered system** (client can't tell if connected directly to server or intermediary), and optionally **code-on-demand** (server can extend client functionality via scripts). These constraints enable scalability, simplicity, and evolvability.

The uniform interface constraint has four sub-constraints: (1) **resource identification via URIs** (e.g., `/books/123`), (2) **resource manipulation through representations** (clients act on JSON/XML representations, not the resources directly), (3) **self-descriptive messages** (each message includes metadata like `Content-Type`, status codes), and (4) **HATEOAS** (Hypermedia As The Engine Of Application State). HATEOAS means responses contain links to related resources and available actions, allowing clients to navigate the API without hardcoding URLs. For example, a book resource returns links to its author, update, and delete endpoints. This decouples clients from server URL schemes.

**HTTP method semantics** are critical for RESTful APIs. **GET** is safe (no side effects) and idempotent (repeated calls produce the same result). **POST** is neither safe nor idempotent (creates resources; repeated calls create duplicates unless idempotency keys are used). **PUT** is idempotent (full replacement; calling twice yields the same result). **PATCH** is partial update (may or may not be idempotent, depending on patch format). **DELETE** is idempotent (deleting a deleted resource is a no-op or returns 404). Using the correct method enables HTTP caching, safe retries, and intermediary optimizations.

**RFC 9457 Problem Details** standardizes error responses with five fields: `type` (URI identifying the error class, e.g., `https://api.example.com/problems/rate-limit-exceeded`), `title` (short human-readable summary), `status` (HTTP status code), `detail` (specific explanation), and `instance` (URI identifying this specific occurrence, e.g., request path). The `Content-Type` must be `application/problem+json`. This structure enables clients to programmatically handle errors (e.g., detect rate limiting by checking `type`) and provide rich feedback to users. Before RFC 9457, error formats were ad-hoc, causing client parsing fragility.

**Key concepts**:

| Concept | Description |
|---------|-------------|
| **Resource** | An addressable entity identified by a URI (e.g., `/books/123`) |
| **Representation** | A serialized form of a resource (e.g., JSON, XML) sent in request/response bodies |
| **Idempotency** | Property where multiple identical requests have the same effect as a single request (GET, PUT, DELETE are idempotent; POST is not) |
| **HATEOAS** | Responses include hypermedia links to related resources and available actions, enabling client navigation |
| **Richardson Maturity Model** | 4-level scale: Level 0 (HTTP tunneling), Level 1 (resources), Level 2 (HTTP verbs + status codes), Level 3 (hypermedia/HATEOAS) |
| **Status Codes** | 200 (OK), 201 (Created), 204 (No Content), 400 (Bad Request), 404 (Not Found), 409 (Conflict), 422 (Validation Error), 429 (Rate Limit) |
| **Pagination** | Offset-based (limit/offset) or cursor-based (opaque token); cursor-based scales better for large datasets |
| **Rate Limiting** | Throttling requests per client using headers: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`, `Retry-After` (429 response) |

**Ecosystem context**: REST alternatives include **GraphQL** (client-driven queries, single endpoint, over-fetching solved but loses HTTP caching), **gRPC** (RPC over HTTP/2, Protocol Buffers, lower latency but less human-readable), and **WebSockets** (bidirectional real-time, not request-response). REST's strengths: HTTP caching, statelessness (scales horizontally), ubiquitous tooling (curl, browsers), and simplicity. Weaknesses: over-fetching/under-fetching (mitigated by GraphQL), chattiness (multiple roundtrips for related resources), and weak contract enforcement (solved by OpenAPI specs). For public-facing APIs, REST dominates due to HTTP ubiquity. For internal microservices with strict performance needs, gRPC is common. For real-time features, WebSockets or Server-Sent Events supplement REST.

## Description

Build a **Book Collection API** that demonstrates professional REST API design: proper resource naming, correct HTTP method/status code semantics, structured error responses (RFC 9457), cursor and offset pagination, filtering, HATEOAS hypermedia links, rate limiting middleware, idempotency, and OpenAPI documentation customization.

The API manages two resources — **books** and **authors** — with a one-to-many relationship (an author has many books). All data is stored in-memory (no database) so the focus stays on API design, not persistence.

### What you'll learn

1. **Resource naming** — plural nouns, hierarchical paths, no verbs in URLs
2. **HTTP method semantics** — GET/POST/PUT/PATCH/DELETE with correct status codes (200, 201, 204, 400, 404, 409, 422, 429)
3. **Structured error responses** — RFC 9457 Problem Details format (`type`, `title`, `status`, `detail`, `instance`)
4. **Pagination** — offset-based with `limit`/`offset` query params and navigation links
5. **Filtering & sorting** — query parameter patterns for collection endpoints
6. **HATEOAS links** — `_links` in responses pointing to related resources and actions
7. **Rate limiting** — custom middleware with `X-RateLimit-*` headers and `429` responses
8. **Idempotency** — `Idempotency-Key` header for safe POST retries
9. **API versioning** — URL-prefix strategy (`/v1/`)
10. **OpenAPI customization** — tags, descriptions, operation IDs, example values

## Instructions

### Phase 1: Setup & Run (~5 min)

1. From this folder: `uv sync`
2. Run the server: `uv run uvicorn app.main:app --reload`
3. Visit `http://localhost:8000/docs` — explore the auto-generated Swagger UI
4. Visit `http://localhost:8000/redoc` — explore the ReDoc alternative
5. Test the health endpoint: `GET http://localhost:8000/v1/health`

### Phase 2: Core CRUD Endpoints (~25 min)

1. Open `app/routes/books.py` — read the existing structure and the `TODO(human)` markers
2. **User implements:** `GET /v1/books` — list all books (return the in-memory list)
3. **User implements:** `POST /v1/books` — create a book, return `201` with `Location` header
4. **User implements:** `GET /v1/books/{book_id}` — return a single book or `404`
5. **User implements:** `PUT /v1/books/{book_id}` — full replace, return `200` or `404`
6. **User implements:** `DELETE /v1/books/{book_id}` — return `204` or `404`
7. Key question: Why return `201 Created` (not `200 OK`) for POST? Why `204 No Content` for DELETE?

### Phase 3: Error Handling — RFC 9457 (~15 min)

1. Open `app/errors.py` — read the `ProblemDetail` model and exception handler scaffold
2. **User implements:** `raise_problem` helper that raises an `HTTPException` with RFC 9457 body
3. **User implements:** Wire the exception handler into `app/main.py`
4. Test: `GET /v1/books/nonexistent-id` should return a structured JSON error, not a plain string
5. Key question: Why include a `type` URI in errors? What benefit does it give API consumers?

### Phase 4: Pagination & Filtering (~20 min)

1. Open `app/routes/books.py` — find the pagination `TODO(human)` markers
2. **User implements:** Offset pagination on `GET /v1/books` using `limit` and `offset` query params
3. **User implements:** Return `_pagination` metadata: `total`, `limit`, `offset`, `next`, `prev` (URLs)
4. **User implements:** Filtering by `author_id`, `genre`, and `year_min`/`year_max` query params
5. **User implements:** Sorting by `title` or `year` with `sort_by` and `order` params
6. Key question: Why is offset pagination simpler but worse for large datasets than cursor pagination?

### Phase 5: HATEOAS Links (~15 min)

1. Open `app/routes/books.py` — find the HATEOAS `TODO(human)` markers
2. **User implements:** Add `_links` to single-book responses: `self`, `author`, `collection`
3. **User implements:** Add `_links` to collection responses: `self`, `next`, `prev`, `first`
4. Key question: How does HATEOAS help API consumers discover available actions without reading docs?

### Phase 6: Rate Limiting Middleware (~15 min)

1. Open `app/middleware.py` — read the middleware scaffold
2. **User implements:** In-memory token bucket or fixed-window rate limiter
3. **User implements:** Set `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset` headers
4. **User implements:** Return `429 Too Many Requests` with `Retry-After` when limit exceeded
5. Key question: Why use a middleware instead of decorating each route?

### Phase 7: Idempotency & Final Touches (~15 min)

1. Open `app/routes/books.py` — find the idempotency `TODO(human)` marker
2. **User implements:** Check `Idempotency-Key` header on POST; if key seen before, return cached response
3. Explore `/docs` — verify all endpoints appear with correct descriptions and examples
4. Final discussion: Which of these patterns (pagination, HATEOAS, RFC 9457, rate limiting) does your current work API use? Which should it adopt?

## Motivation

- **Universal skill**: Every backend developer designs REST APIs — doing it well separates senior from junior engineers
- **Complementary to current work**: AutoScheduler.AI uses FastAPI; these patterns directly improve production API quality
- **Industry standard**: RFC 9457 error format, HATEOAS, and rate limiting are expected in professional-grade APIs
- **Interview-relevant**: REST API design is one of the most common system design interview topics
- **OpenAPI literacy**: Understanding auto-generated docs enables better API-first development workflows

## References

- [Microsoft REST API Design Guidelines](https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design)
- [RFC 9457 — Problem Details for HTTP APIs](https://www.rfc-editor.org/rfc/rfc9457.html)
- [RFC 7807 — Problem Details (original)](https://datatracker.ietf.org/doc/html/rfc7807)
- [FastAPI Official Documentation](https://fastapi.tiangolo.com/)
- [Pydantic v2 Documentation](https://docs.pydantic.dev/latest/)
- [RESTful API Design Guide — Strapi](https://strapi.io/blog/restful-api-design-guide-principles-best-practices)
- [REST API Rate Limiting Guidelines](https://restfulapi.net/rest-api-rate-limit-guidelines/)
- [IETF RateLimit Header Fields Draft](https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-02.html)

## Commands

### Setup

| Command | Description |
|---------|-------------|
| `uv sync` | Install all dependencies (FastAPI, Pydantic, uvicorn, httpx) |

### Run Server

| Command | Description |
|---------|-------------|
| `uv run uvicorn app.main:app --reload` | Start the FastAPI server with auto-reload on code changes |

### Browse API Docs

| Command | Description |
|---------|-------------|
| Open `http://localhost:8000/docs` | Swagger UI -- interactive API documentation |
| Open `http://localhost:8000/redoc` | ReDoc -- alternative API documentation |

### Test Endpoints (curl / httpx)

| Command | Description |
|---------|-------------|
| `curl http://localhost:8000/v1/health` | Health check endpoint |
| `curl http://localhost:8000/v1/authors` | List all authors |
| `curl http://localhost:8000/v1/books` | List all books (paginated) |
| `curl http://localhost:8000/v1/books?limit=5&offset=0` | List books with explicit pagination |
| `curl http://localhost:8000/v1/books?genre=Fantasy&sort_by=year&order=desc` | List books with filtering and sorting |
| `curl -X POST http://localhost:8000/v1/books -H "Content-Type: application/json" -d '{"title":"Test","author_id":"auth_marquez1","genre":"Fiction","year":2000}'` | Create a new book |
| `curl -X POST http://localhost:8000/v1/books -H "Content-Type: application/json" -H "Idempotency-Key: my-key-123" -d '{"title":"Test","author_id":"auth_marquez1","genre":"Fiction","year":2000}'` | Create a book with idempotency key |
| `curl http://localhost:8000/v1/books/{book_id}` | Get a single book by ID |
| `curl -X PUT http://localhost:8000/v1/books/{book_id} -H "Content-Type: application/json" -d '{"title":"Updated","author_id":"auth_marquez1","genre":"Fiction","year":2001}'` | Replace a book entirely |
| `curl -X DELETE http://localhost:8000/v1/books/{book_id}` | Delete a book |

## State

`not-started`
