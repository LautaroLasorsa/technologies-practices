# Practice 016: REST API Design Principles

## Technologies

- **FastAPI** — Modern Python web framework with automatic OpenAPI generation
- **Pydantic v2** — Data validation and serialization via Python type hints
- **OpenAPI 3.1** — API specification standard (auto-generated by FastAPI)
- **RFC 9457 / RFC 7807** — Problem Details for HTTP APIs (structured error responses)
- **HATEOAS** — Hypermedia as the Engine of Application State

## Stack

- Python 3.12+ (uv)

## Description

Build a **Book Collection API** that demonstrates professional REST API design: proper resource naming, correct HTTP method/status code semantics, structured error responses (RFC 9457), cursor and offset pagination, filtering, HATEOAS hypermedia links, rate limiting middleware, idempotency, and OpenAPI documentation customization.

The API manages two resources — **books** and **authors** — with a one-to-many relationship (an author has many books). All data is stored in-memory (no database) so the focus stays on API design, not persistence.

### What you'll learn

1. **Resource naming** — plural nouns, hierarchical paths, no verbs in URLs
2. **HTTP method semantics** — GET/POST/PUT/PATCH/DELETE with correct status codes (200, 201, 204, 400, 404, 409, 422, 429)
3. **Structured error responses** — RFC 9457 Problem Details format (`type`, `title`, `status`, `detail`, `instance`)
4. **Pagination** — offset-based with `limit`/`offset` query params and navigation links
5. **Filtering & sorting** — query parameter patterns for collection endpoints
6. **HATEOAS links** — `_links` in responses pointing to related resources and actions
7. **Rate limiting** — custom middleware with `X-RateLimit-*` headers and `429` responses
8. **Idempotency** — `Idempotency-Key` header for safe POST retries
9. **API versioning** — URL-prefix strategy (`/v1/`)
10. **OpenAPI customization** — tags, descriptions, operation IDs, example values

## Instructions

### Phase 1: Setup & Run (~5 min)

1. From this folder: `uv sync`
2. Run the server: `uv run uvicorn app.main:app --reload`
3. Visit `http://localhost:8000/docs` — explore the auto-generated Swagger UI
4. Visit `http://localhost:8000/redoc` — explore the ReDoc alternative
5. Test the health endpoint: `GET http://localhost:8000/v1/health`

### Phase 2: Core CRUD Endpoints (~25 min)

1. Open `app/routes/books.py` — read the existing structure and the `TODO(human)` markers
2. **User implements:** `GET /v1/books` — list all books (return the in-memory list)
3. **User implements:** `POST /v1/books` — create a book, return `201` with `Location` header
4. **User implements:** `GET /v1/books/{book_id}` — return a single book or `404`
5. **User implements:** `PUT /v1/books/{book_id}` — full replace, return `200` or `404`
6. **User implements:** `DELETE /v1/books/{book_id}` — return `204` or `404`
7. Key question: Why return `201 Created` (not `200 OK`) for POST? Why `204 No Content` for DELETE?

### Phase 3: Error Handling — RFC 9457 (~15 min)

1. Open `app/errors.py` — read the `ProblemDetail` model and exception handler scaffold
2. **User implements:** `raise_problem` helper that raises an `HTTPException` with RFC 9457 body
3. **User implements:** Wire the exception handler into `app/main.py`
4. Test: `GET /v1/books/nonexistent-id` should return a structured JSON error, not a plain string
5. Key question: Why include a `type` URI in errors? What benefit does it give API consumers?

### Phase 4: Pagination & Filtering (~20 min)

1. Open `app/routes/books.py` — find the pagination `TODO(human)` markers
2. **User implements:** Offset pagination on `GET /v1/books` using `limit` and `offset` query params
3. **User implements:** Return `_pagination` metadata: `total`, `limit`, `offset`, `next`, `prev` (URLs)
4. **User implements:** Filtering by `author_id`, `genre`, and `year_min`/`year_max` query params
5. **User implements:** Sorting by `title` or `year` with `sort_by` and `order` params
6. Key question: Why is offset pagination simpler but worse for large datasets than cursor pagination?

### Phase 5: HATEOAS Links (~15 min)

1. Open `app/routes/books.py` — find the HATEOAS `TODO(human)` markers
2. **User implements:** Add `_links` to single-book responses: `self`, `author`, `collection`
3. **User implements:** Add `_links` to collection responses: `self`, `next`, `prev`, `first`
4. Key question: How does HATEOAS help API consumers discover available actions without reading docs?

### Phase 6: Rate Limiting Middleware (~15 min)

1. Open `app/middleware.py` — read the middleware scaffold
2. **User implements:** In-memory token bucket or fixed-window rate limiter
3. **User implements:** Set `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset` headers
4. **User implements:** Return `429 Too Many Requests` with `Retry-After` when limit exceeded
5. Key question: Why use a middleware instead of decorating each route?

### Phase 7: Idempotency & Final Touches (~15 min)

1. Open `app/routes/books.py` — find the idempotency `TODO(human)` marker
2. **User implements:** Check `Idempotency-Key` header on POST; if key seen before, return cached response
3. Explore `/docs` — verify all endpoints appear with correct descriptions and examples
4. Final discussion: Which of these patterns (pagination, HATEOAS, RFC 9457, rate limiting) does your current work API use? Which should it adopt?

## Motivation

- **Universal skill**: Every backend developer designs REST APIs — doing it well separates senior from junior engineers
- **Complementary to current work**: AutoScheduler.AI uses FastAPI; these patterns directly improve production API quality
- **Industry standard**: RFC 9457 error format, HATEOAS, and rate limiting are expected in professional-grade APIs
- **Interview-relevant**: REST API design is one of the most common system design interview topics
- **OpenAPI literacy**: Understanding auto-generated docs enables better API-first development workflows

## References

- [Microsoft REST API Design Guidelines](https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design)
- [RFC 9457 — Problem Details for HTTP APIs](https://www.rfc-editor.org/rfc/rfc9457.html)
- [RFC 7807 — Problem Details (original)](https://datatracker.ietf.org/doc/html/rfc7807)
- [FastAPI Official Documentation](https://fastapi.tiangolo.com/)
- [Pydantic v2 Documentation](https://docs.pydantic.dev/latest/)
- [RESTful API Design Guide — Strapi](https://strapi.io/blog/restful-api-design-guide-principles-best-practices)
- [REST API Rate Limiting Guidelines](https://restfulapi.net/rest-api-rate-limit-guidelines/)
- [IETF RateLimit Header Fields Draft](https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-02.html)

## Commands

### Setup

| Command | Description |
|---------|-------------|
| `uv sync` | Install all dependencies (FastAPI, Pydantic, uvicorn, httpx) |

### Run Server

| Command | Description |
|---------|-------------|
| `uv run uvicorn app.main:app --reload` | Start the FastAPI server with auto-reload on code changes |

### Browse API Docs

| Command | Description |
|---------|-------------|
| Open `http://localhost:8000/docs` | Swagger UI -- interactive API documentation |
| Open `http://localhost:8000/redoc` | ReDoc -- alternative API documentation |

### Test Endpoints (curl / httpx)

| Command | Description |
|---------|-------------|
| `curl http://localhost:8000/v1/health` | Health check endpoint |
| `curl http://localhost:8000/v1/authors` | List all authors |
| `curl http://localhost:8000/v1/books` | List all books (paginated) |
| `curl http://localhost:8000/v1/books?limit=5&offset=0` | List books with explicit pagination |
| `curl http://localhost:8000/v1/books?genre=Fantasy&sort_by=year&order=desc` | List books with filtering and sorting |
| `curl -X POST http://localhost:8000/v1/books -H "Content-Type: application/json" -d '{"title":"Test","author_id":"auth_marquez1","genre":"Fiction","year":2000}'` | Create a new book |
| `curl -X POST http://localhost:8000/v1/books -H "Content-Type: application/json" -H "Idempotency-Key: my-key-123" -d '{"title":"Test","author_id":"auth_marquez1","genre":"Fiction","year":2000}'` | Create a book with idempotency key |
| `curl http://localhost:8000/v1/books/{book_id}` | Get a single book by ID |
| `curl -X PUT http://localhost:8000/v1/books/{book_id} -H "Content-Type: application/json" -d '{"title":"Updated","author_id":"auth_marquez1","genre":"Fiction","year":2001}'` | Replace a book entirely |
| `curl -X DELETE http://localhost:8000/v1/books/{book_id}` | Delete a book |

## State

`not-started`
