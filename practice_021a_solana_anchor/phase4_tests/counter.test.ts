// =============================================================================
// Phase 4: Testing with LiteSVM
// =============================================================================
//
// REFERENCE FILE: Copy into tests/solana_practice.ts (or a new test file)
//
// KEY CONCEPTS:
//
// 1. LiteSVM runs a Solana VM IN-PROCESS -- no separate validator needed.
//    This makes tests ~25x faster than solana-test-validator.
//
// 2. anchor-litesvm provides `fromWorkspace()` which:
//    - Reads your Anchor.toml
//    - Loads the compiled .so from target/deploy/
//    - Sets up a LiteSVM instance with your program deployed
//
// 3. LiteSVMProvider wraps LiteSVM to act like AnchorProvider,
//    so you use the same `program.methods.xxx().accounts({}).rpc()` API.
//
// 4. Test structure:
//    - Create a LiteSVM instance from workspace
//    - Fund test accounts via svm.airdrop()
//    - Send transactions via program.methods.xxx()
//    - Fetch account data via program.account.xxx.fetch()
//    - Assert results
//
// SETUP:
//   npm install --save-dev litesvm anchor-litesvm
//   Make sure `anchor build` has been run first (needs the .so file)
//
// =============================================================================

import { fromWorkspace, LiteSVMProvider } from "anchor-litesvm";
import { Keypair, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
import { BN, Program, Wallet } from "@coral-xyz/anchor";
import * as anchor from "@coral-xyz/anchor";

// Import your program's IDL type (generated by anchor build)
// Adjust the path based on your project structure
import { SolanaPractice } from "../target/types/solana_practice";
const IDL = require("../target/idl/solana_practice.json");

describe("Solana Practice -- Counter Tests", () => {
  // =========================================================================
  // Test Setup
  // =========================================================================
  //
  // fromWorkspace(".") reads Anchor.toml from the current directory,
  // loads the compiled program, and creates a LiteSVM instance.
  //
  // LiteSVMProvider wraps it so Anchor's TypeScript client works normally.
  //
  let svm: ReturnType<typeof fromWorkspace>;
  let provider: LiteSVMProvider;
  let program: Program<SolanaPractice>;
  let user: Keypair;

  beforeAll(() => {
    // Initialize LiteSVM from the workspace
    // .withSysvars() adds clock, rent, etc. -- needed for most programs
    svm = fromWorkspace(".")
      .withSysvars();

    provider = new LiteSVMProvider(svm);
    anchor.setProvider(provider);

    // Load the program using the IDL
    program = new Program<SolanaPractice>(IDL, provider);

    // Create and fund a test user
    user = Keypair.generate();
    svm.airdrop(user.publicKey, BigInt(10 * LAMPORTS_PER_SOL));
  });

  // =========================================================================
  // Exercise 1: Create counter, increment 3 times, verify count == 3
  // =========================================================================
  //
  // This test exercises the full lifecycle:
  //   1. Initialize a counter account
  //   2. Increment it 3 times
  //   3. Fetch the account data and verify count == 3
  //
  describe("Counter lifecycle", () => {
    const counterKeypair = Keypair.generate();

    it("initializes a counter", async () => {
      // TODO(human): Call program.methods.initialize() with the right accounts
      //
      // Hint:
      //   await program.methods
      //     .initialize()
      //     .accounts({
      //       counter: counterKeypair.publicKey,
      //       user: user.publicKey,
      //       systemProgram: anchor.web3.SystemProgram.programId,
      //     })
      //     .signers([user, counterKeypair])
      //     .rpc();
      //

      // Fetch the counter account and verify initial state
      const counter = await program.account.counter.fetch(
        counterKeypair.publicKey
      );

      // TODO(human): Assert that counter.count equals 0
      //   Hint: expect(counter.count.toNumber()).toBe(0);
      //
      // TODO(human): Assert that counter.authority equals user.publicKey
      //   Hint: expect(counter.authority.toBase58()).toBe(user.publicKey.toBase58());
      //
    });

    it("increments the counter 3 times", async () => {
      // TODO(human): Call increment 3 times in a loop
      //
      // Hint:
      //   for (let i = 0; i < 3; i++) {
      //     await program.methods
      //       .increment()
      //       .accounts({
      //         counter: counterKeypair.publicKey,
      //         authority: user.publicKey,
      //       })
      //       .signers([user])
      //       .rpc();
      //   }
      //

      // Fetch and verify
      const counter = await program.account.counter.fetch(
        counterKeypair.publicKey
      );

      // TODO(human): Assert count == 3
      //   Hint: expect(counter.count.toNumber()).toBe(3);
      //
    });
  });

  // =========================================================================
  // Exercise 2: Test error -- decrement below zero
  // =========================================================================
  //
  // Testing error cases is crucial. Anchor programs return specific error
  // codes that you can match against.
  //
  // Pattern for testing errors:
  //   try {
  //     await program.methods.decrement().accounts({...}).signers([...]).rpc();
  //     fail("Should have thrown");
  //   } catch (err) {
  //     // Verify it's the expected error
  //     expect(err.toString()).toContain("expected error message");
  //   }
  //
  describe("Error handling", () => {
    const counterKeypair = Keypair.generate();

    beforeAll(async () => {
      // Create a fresh counter at count = 0
      await program.methods
        .initialize()
        .accounts({
          counter: counterKeypair.publicKey,
          user: user.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([user, counterKeypair])
        .rpc();
    });

    it("fails to decrement below zero", async () => {
      // TODO(human): Try to decrement a counter with count = 0
      //   This should fail with an error.
      //
      // Hint:
      //   try {
      //     await program.methods
      //       .decrement()
      //       .accounts({
      //         counter: counterKeypair.publicKey,
      //         authority: user.publicKey,
      //       })
      //       .signers([user])
      //       .rpc();
      //     fail("Expected error: counter underflow");
      //   } catch (err) {
      //     // Verify it's the right error, not a random failure
      //     expect(err.toString()).toContain("InvalidArgument");
      //     // Or if you defined custom errors (Phase 6):
      //     // expect(err.toString()).toContain("CounterUnderflow");
      //   }
      //
    });
  });

  // =========================================================================
  // Exercise 3: Test unauthorized access
  // =========================================================================
  //
  // Once you add `has_one = authority` to your Accounts structs,
  // only the original authority can increment/decrement.
  // An unauthorized user should get an error.
  //
  describe("Access control", () => {
    const counterKeypair = Keypair.generate();
    let attacker: Keypair;

    beforeAll(async () => {
      // Create counter owned by `user`
      await program.methods
        .initialize()
        .accounts({
          counter: counterKeypair.publicKey,
          user: user.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([user, counterKeypair])
        .rpc();

      // Create and fund an attacker
      attacker = Keypair.generate();
      svm.airdrop(attacker.publicKey, BigInt(10 * LAMPORTS_PER_SOL));
    });

    it("rejects unauthorized increment", async () => {
      // TODO(human): Try to increment using `attacker` as authority
      //   This should fail because counter.authority != attacker.publicKey
      //
      // Hint:
      //   try {
      //     await program.methods
      //       .increment()
      //       .accounts({
      //         counter: counterKeypair.publicKey,
      //         authority: attacker.publicKey,
      //       })
      //       .signers([attacker])
      //       .rpc();
      //     fail("Expected error: unauthorized");
      //   } catch (err) {
      //     // has_one constraint violation
      //     expect(err.toString()).toContain("has_one");
      //     // Or: expect(err.toString()).toContain("ConstraintHasOne");
      //   }
      //
    });
  });

  // =========================================================================
  // Exercise 4: Test PDA derivation
  // =========================================================================
  //
  // Verify that the client-side PDA derivation matches what the program expects.
  //
  describe("PDA Counter", () => {
    it("derives PDA correctly and creates counter", async () => {
      // TODO(human): Derive the PDA client-side
      //
      // Hint:
      //   const [counterPda, bump] = PublicKey.findProgramAddressSync(
      //     [Buffer.from("counter"), user.publicKey.toBuffer()],
      //     program.programId
      //   );
      //
      //   console.log("PDA:", counterPda.toBase58(), "bump:", bump);
      //

      // TODO(human): Initialize the PDA counter
      //
      // Hint:
      //   await program.methods
      //     .initializePdaCounter()
      //     .accounts({
      //       counter: counterPda,       // pass the derived PDA
      //       user: user.publicKey,
      //       systemProgram: anchor.web3.SystemProgram.programId,
      //     })
      //     .signers([user])
      //     .rpc();
      //
      // Notice: NO counterKeypair signer needed!
      // The PDA is derived, not a random keypair. Only the user signs.
      //

      // TODO(human): Fetch the PDA counter and verify
      //
      // Hint:
      //   const counter = await program.account.pdaCounter.fetch(counterPda);
      //   expect(counter.count.toNumber()).toBe(0);
      //   expect(counter.bump).toBe(bump);  // stored bump matches derived bump
      //
    });

    it("increments PDA counter", async () => {
      // TODO(human): Derive the SAME PDA (deterministic!)
      //   and call increment_pda_counter
      //
      // Key insight: you don't need to "look up" the counter address.
      // You recompute it from the same seeds. This is the power of PDAs.
      //
    });
  });

  // =========================================================================
  // Exercise 5 (bonus): Measure compute units
  // =========================================================================
  //
  // Solana charges for computation in "compute units" (CU), like gas.
  // Default budget: 200,000 CU per instruction.
  //
  // You can check CU usage by inspecting transaction logs:
  //
  //   const tx = await program.methods.increment()
  //     .accounts({...}).signers([...]).rpc();
  //
  //   // In LiteSVM, inspect the transaction result for CU consumed
  //   console.log("Transaction:", tx);
  //
  // This is useful for optimizing programs -- some operations are
  // surprisingly expensive (e.g., PDA derivation costs ~1500 CU).
  //
});

// =============================================================================
// NOTES ON TEST FRAMEWORK
// =============================================================================
//
// The default Anchor test setup uses Mocha (describe/it/before).
// If you prefer Jest, update package.json and use beforeAll/afterAll instead.
//
// LiteSVM vs solana-test-validator:
//   - LiteSVM: In-process, ~25x faster, no port conflicts, no cleanup needed
//   - test-validator: Full validator, supports all features, needed for complex
//     programs (e.g., with oracles, lookups), but slow to start/stop
//
// For this practice, LiteSVM is sufficient for all exercises.
//
// If LiteSVM gives you trouble, you can fall back to `anchor test` which
// uses solana-test-validator. The test code is the same -- only the
// provider setup changes.
//
// Fallback provider setup (solana-test-validator):
//   const provider = anchor.AnchorProvider.env();
//   anchor.setProvider(provider);
//   const program = anchor.workspace.SolanaPractice as Program<SolanaPractice>;
//
// =============================================================================
