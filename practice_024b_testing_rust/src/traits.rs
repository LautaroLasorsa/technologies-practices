//! Traits for dependency injection and testability.
//!
//! Phase 4: These traits allow mocking in tests.
//! mockall's #[automock] generates MockTimeProvider and MockHttpClient.

use std::time::Instant;

#[cfg(test)]
use mockall::automock;

use crate::error::CacheError;

/// Provides the current time — mockable for deterministic tests.
///
/// In production, use SystemTimeProvider (implemented below).
/// In tests, use MockTimeProvider (generated by #[automock]).
///
/// Why a trait? Rust doesn't let you mock free functions or
/// Instant::now() directly. By abstracting time behind a trait,
/// tests can control "what time it is" precisely.
///
/// Compare with Python: in Python you'd monkeypatch datetime.now()
/// or time.time(). In Rust, the type system requires this trait-based
/// approach, which is more explicit but also more type-safe.
#[cfg_attr(test, automock)]
pub trait TimeProvider: Send + Sync {
    /// Returns the current instant.
    fn now(&self) -> Instant;
}

/// Production time provider — just calls Instant::now().
///
/// This is the "real" implementation used in production code.
/// It's trivial, but the trait abstraction is what makes
/// the cache testable with deterministic time.
pub struct SystemTimeProvider;

impl TimeProvider for SystemTimeProvider {
    fn now(&self) -> Instant {
        Instant::now()
    }
}

/// HTTP client for cache-aside pattern — mockable for tests.
///
/// TODO(human): Add the #[cfg_attr(test, automock)] attribute to this trait.
///
/// The cache-aside pattern works like this:
/// 1. Client asks cache for a key
/// 2. Cache miss → fetch from origin via HttpClient
/// 3. Store result in cache
/// 4. Return to client
///
/// In tests, MockHttpClient lets you simulate:
/// - Successful fetches (returning specific data)
/// - Network failures (returning CacheError::FetchError)
/// - Slow responses (with tokio time control)
///
/// Why mock this? You don't want tests hitting real HTTP endpoints.
/// Mocking lets you test cache behavior in isolation, controlling
/// exactly what the "network" returns.
///
/// The #[cfg_attr(test, automock)] attribute tells mockall to generate
/// a MockHttpClient struct ONLY when compiling in test mode (#[cfg(test)]).
/// This means production builds don't include any mock code.
///
/// After adding the attribute, you can use MockHttpClient in tests:
///   let mut mock = MockHttpClient::new();
///   mock.expect_fetch()
///       .with(eq("https://api.example.com/key1"))
///       .returning(|_| Box::pin(async { Ok("value1".to_string()) }));

// TODO(human): Add #[cfg_attr(test, automock)] here
pub trait HttpClient: Send + Sync {
    /// Fetch a value from the given URL.
    ///
    /// Returns Ok(String) on success, Err(CacheError::FetchError) on failure.
    fn fetch(
        &self,
        url: &str,
    ) -> impl std::future::Future<Output = Result<String, CacheError>> + Send;
}
