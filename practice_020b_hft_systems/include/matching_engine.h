#pragma once

// =============================================================================
// matching_engine.h -- Price-Time Priority Matching Engine
//
// The matching engine is the HEART of every exchange. It takes incoming orders,
// attempts to match them against resting orders in the book, and generates
// trades for every fill.
//
// MATCHING ALGORITHM (Price-Time Priority / FIFO):
//   1. Incoming BUY order: match against ASK side, starting at the lowest ask
//      - Match if incoming.price >= resting.price (buyer willing to pay enough)
//   2. Incoming SELL order: match against BID side, starting at the highest bid
//      - Match if incoming.price <= resting.price (seller willing to accept enough)
//   3. At each price level, match orders in FIFO order (time priority)
//   4. Continue until: incoming order filled, no more matchable levels, or FOK fails
//   5. If LIMIT order has remaining quantity, add it to the book (becomes passive)
//   6. If IOC order has remaining quantity, cancel it (don't rest)
//   7. If FOK order can't be fully filled, cancel entirely (no partial fills)
//
// TRADE GENERATION:
//   Each match produces a Trade record with:
//   - Execution price: always the RESTING order's price (the maker's price)
//     This is because the maker was there first and set their terms.
//   - Quantity: min(incoming.remaining, resting.remaining)
//   - Aggressor (taker): the incoming order
//   - Passive (maker): the resting order
//
// REAL-WORLD CONTEXT:
//   - Nasdaq's matching engine processes an order in < 50 microseconds
//   - CME Globex: < 5 microseconds for a match cycle
//   - IEX intentionally adds 350 microseconds delay (speed bump)
//   - Crypto exchanges (Binance, Coinbase): ~1-10 milliseconds
//
// WHY PRICE-TIME PRIORITY:
//   It's the simplest fair rule: best price wins, ties broken by arrival time.
//   Alternatives: pro-rata (CME for some products), price-size-time (rare).
// =============================================================================

#include <vector>

#include "order_book.h"
#include "types.h"

// Result of submitting an order to the matching engine.
struct MatchResult {
    std::vector<Trade> trades;       // Trades generated by this order
    std::optional<Order> resting;    // The order if it was added to the book (LIMIT only)
    qty_t filled_qty    = 0;         // Total quantity filled
    qty_t remaining_qty = 0;         // Remaining unfilled quantity
    bool  was_resting   = false;     // True if order was added to the book
    bool  was_cancelled = false;     // True if IOC/FOK remainder was cancelled

    bool fully_filled() const { return remaining_qty <= 0; }
};

class MatchingEngine {
public:
    // Submit an order to the matching engine.
    //
    // This is the main entry point. The engine will:
    //   1. Attempt to match the incoming order against the opposite side of the book
    //   2. Generate Trade records for each fill
    //   3. Handle the remainder based on order type (LIMIT/IOC/FOK)
    //
    // TODO(human): Implement this.
    // Hint (high-level structure):
    //   1. For FOK orders: first CHECK if the full quantity can be filled (dry run)
    //      - Walk the opposite side and sum available qty at matchable prices
    //      - If not enough, return immediately with was_cancelled = true
    //   2. Call match_against_book() to do the actual matching
    //   3. Based on order type:
    //      - LIMIT with remaining qty: add to book (order becomes passive)
    //      - IOC with remaining qty: cancel remainder
    //      - FOK: already handled in step 1
    //   4. Return the MatchResult
    MatchResult submit_order(Order order);

    // Access the underlying order book (for queries, snapshots, etc.)
    OrderBook& book() { return book_; }
    const OrderBook& book() const { return book_; }

    // Get the next trade ID (monotonically increasing).
    TradeId next_trade_id() { return next_trade_id_++; }

    // Total number of trades generated since engine start.
    TradeId trade_count() const { return next_trade_id_; }

private:
    // Match an incoming order against the opposite side of the book.
    //
    // TODO(human): Implement this.
    // Hint (step by step):
    //   1. Get the opposite side map:
    //      - If incoming is BUY, match against asks (begin = best/lowest ask)
    //      - If incoming is SELL, match against bids (rbegin = best/highest bid)
    //   2. Walk price levels in order:
    //      - For BUY: iterate asks from begin() while ask.price <= incoming.price
    //      - For SELL: iterate bids from rbegin() while bid.price >= incoming.price
    //   3. At each level, walk orders in FIFO order:
    //      - fill_qty = min(incoming.remaining_qty, resting.remaining_qty)
    //      - Reduce both orders' remaining_qty by fill_qty
    //      - Create a Trade: price = resting.price, qty = fill_qty
    //      - If resting order is filled, remove it from the level
    //   4. If a price level becomes empty, erase it from the map
    //   5. Stop when incoming order is filled or no more matchable levels
    //
    // IMPORTANT: The execution price is ALWAYS the resting order's price.
    // The aggressor "crosses the spread" and gets the maker's price.
    //
    // Watch out for iterator invalidation when erasing from std::map during iteration!
    // Pattern: use it = map.erase(it) instead of map.erase(it++)
    std::vector<Trade> match_against_book(Order& incoming);

    // Check if a FOK order can be fully filled (without actually matching).
    //
    // TODO(human): Implement this.
    // Hint: Walk the opposite side the same way as match_against_book,
    // but only count available quantity, don't modify anything.
    // Return true if available qty >= order.remaining_qty.
    bool can_fill_completely(const Order& order) const;

    OrderBook book_;
    TradeId   next_trade_id_ = 1;
};
