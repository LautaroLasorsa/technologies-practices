use std::collections::HashMap;
use std::sync::Arc;

use tokio::sync::{mpsc, Mutex};
use tokio_stream::wrappers::ReceiverStream;
use tonic::{Request, Response, Status, transport::Server};

// Pull in the generated protobuf types and the service trait.
// `tonic::include_proto!` expands to the code generated by tonic-prost-build
// from `proto/inventory.proto`. The string must match the `package` name in the .proto file.
pub mod inventory {
    tonic::include_proto!("inventory");
}

use inventory::inventory_server::{Inventory, InventoryServer};
use inventory::{
    AddItemRequest, AddItemResponse, GetItemRequest, GetItemResponse, ListItemsRequest,
    ListItemsResponse,
};

// ── Domain model ────────────────────────────────────────────────────

/// In-memory representation of an inventory item.
#[derive(Debug, Clone)]
struct Item {
    name: String,
    quantity: i32,
    price: f64,
}

// ── Service implementation ──────────────────────────────────────────

/// The gRPC service struct. Holds shared state behind Arc<Mutex<_>>
/// so it can be safely shared across async tasks.
#[derive(Debug)]
struct InventoryService {
    /// Stores items keyed by name. Arc<Mutex<_>> because tonic spawns a
    /// new task per request, and they all need access to the same store.
    store: Arc<Mutex<HashMap<String, Item>>>,
}

impl InventoryService {
    fn new() -> Self {
        Self {
            store: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

#[tonic::async_trait]
impl Inventory for InventoryService {
    /// Unary RPC: Add a new item to the inventory.
    ///
    /// TODO(human): Implement this method.
    ///
    /// Steps:
    ///   1. Extract the inner message from the request with `request.into_inner()`
    ///   2. Lock the store with `self.store.lock().await`
    ///   3. Check if the item already exists -- if so, return `Status::already_exists(...)`
    ///   4. Insert a new `Item` into the store
    ///   5. Return an `AddItemResponse` with name and status = "created"
    ///
    /// Hint: `Ok(Response::new(AddItemResponse { ... }))`
    async fn add_item(
        &self,
        request: Request<AddItemRequest>,
    ) -> Result<Response<AddItemResponse>, Status> {
        todo!("TODO(human): implement add_item")
    }

    /// Unary RPC: Look up a single item by name.
    ///
    /// TODO(human): Implement this method.
    ///
    /// Steps:
    ///   1. Get the item name from the request
    ///   2. Lock the store and look up the item
    ///   3. If not found, return `Status::not_found("item 'X' not found")`
    ///   4. If found, return a `GetItemResponse` with the item's fields
    async fn get_item(
        &self,
        request: Request<GetItemRequest>,
    ) -> Result<Response<GetItemResponse>, Status> {
        todo!("TODO(human): implement get_item")
    }

    /// The associated type for the server-streaming response.
    /// tonic requires you to define a concrete Stream type here.
    /// `ReceiverStream` wraps a `tokio::sync::mpsc::Receiver` into a Stream.
    type ListItemsStream = ReceiverStream<Result<ListItemsResponse, Status>>;

    /// Server-streaming RPC: Stream all items in the inventory.
    ///
    /// TODO(human): Implement this method.
    ///
    /// Steps:
    ///   1. Create an `mpsc::channel::<Result<ListItemsResponse, Status>>(128)`
    ///   2. Clone the store Arc and spawn a tokio task that:
    ///      a. Locks the store
    ///      b. Iterates over all items
    ///      c. Sends each item through `tx.send(Ok(ListItemsResponse { ... })).await`
    ///   3. Return `Ok(Response::new(ReceiverStream::new(rx)))`
    ///
    /// Hint: The spawned task runs concurrently -- tonic reads from `rx`
    /// as you push items into `tx`. This is the core server-streaming pattern.
    async fn list_items(
        &self,
        _request: Request<ListItemsRequest>,
    ) -> Result<Response<Self::ListItemsStream>, Status> {
        todo!("TODO(human): implement list_items")
    }
}

// ── Server entrypoint ───────────────────────────────────────────────

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "127.0.0.1:50051".parse()?;
    let service = InventoryService::new();

    println!("InventoryServer listening on {addr}");

    Server::builder()
        .add_service(InventoryServer::new(service))
        .serve(addr)
        .await?;

    Ok(())
}
