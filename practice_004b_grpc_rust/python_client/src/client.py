"""
gRPC client that connects to the Rust Inventory server.

Usage (from python_client/):
    uv run python src/client.py

Prerequisites:
    1. Generate stubs first:
       uv run python -m grpc_tools.protoc \
           -I../proto --python_out=./src --grpc_python_out=./src \
           ../proto/inventory.proto
    2. Start the Rust server: cargo run  (from rust_server/)
"""

from __future__ import annotations

import grpc

# These modules are generated by grpc_tools.protoc from inventory.proto.
# They will NOT exist until you run the codegen command above.
import inventory_pb2
import inventory_pb2_grpc

SERVER_ADDRESS = "localhost:50051"


def run_add_items(stub: inventory_pb2_grpc.InventoryStub) -> None:
    """Add several items to the inventory via unary RPCs.

    TODO(human): Implement this function.

    Steps:
      1. Create an AddItemRequest with name, quantity, and price
      2. Call stub.AddItem(request)
      3. Print the response (name and status)
      4. Add at least 3 different items
      5. Try adding a duplicate item -- catch grpc.RpcError and print the
         error code and details

    Hint:
        request = inventory_pb2.AddItemRequest(
            name="Widget", quantity=100, price=9.99
        )
        response = stub.AddItem(request)

    For error handling:
        try:
            stub.AddItem(duplicate_request)
        except grpc.RpcError as e:
            print(f"Error: code={e.code()}, details={e.details()}")
    """
    raise NotImplementedError("TODO(human): implement run_add_items")


def run_get_item(stub: inventory_pb2_grpc.InventoryStub) -> None:
    """Query a single item by name -- test both found and not-found cases.

    TODO(human): Implement this function.

    Steps:
      1. Create a GetItemRequest for an item you added
      2. Call stub.GetItem(request) and print the response fields
      3. Create a GetItemRequest for a non-existing item
      4. Catch grpc.RpcError -- verify the status code is NOT_FOUND

    Hint:
        request = inventory_pb2.GetItemRequest(name="Widget")
        response = stub.GetItem(request)
        print(f"{response.name}: qty={response.quantity}, price={response.price}")
    """
    raise NotImplementedError("TODO(human): implement run_get_item")


def run_list_items(stub: inventory_pb2_grpc.InventoryStub) -> None:
    """List all items using server-side streaming.

    TODO(human): Implement this function.

    Steps:
      1. Create a ListItemsRequest (empty message)
      2. Call stub.ListItems(request) -- this returns an iterator
      3. Loop over the iterator and print each item

    Hint:
        request = inventory_pb2.ListItemsRequest()
        for item in stub.ListItems(request):
            print(f"  {item.name}: qty={item.quantity}, price={item.price}")

    Key insight: each iteration of the for-loop receives one message
    from the Rust server's mpsc channel stream.
    """
    raise NotImplementedError("TODO(human): implement run_list_items")


def main() -> None:
    """Connect to the Rust gRPC server and exercise all three RPCs."""
    print(f"Connecting to Inventory server at {SERVER_ADDRESS}...")

    with grpc.insecure_channel(SERVER_ADDRESS) as channel:
        stub = inventory_pb2_grpc.InventoryStub(channel)

        print("\n=== Adding items ===")
        run_add_items(stub)

        print("\n=== Getting items ===")
        run_get_item(stub)

        print("\n=== Listing all items (server stream) ===")
        run_list_items(stub)

    print("\nDone.")


if __name__ == "__main__":
    main()
