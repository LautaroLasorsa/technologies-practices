# Practice 058a -- SQLModel: FastAPI Integration & Pydantic Models

## Technologies

- **SQLModel** (v0.0.22+) -- ORM library that unifies SQLAlchemy and Pydantic into a single class
- **FastAPI** (v0.115+) -- Modern async Python web framework with automatic OpenAPI docs
- **PostgreSQL 16** -- Relational database (via Docker)
- **Pydantic** (v2) -- Data validation library (used internally by SQLModel)
- **SQLAlchemy 2.0** -- SQL toolkit and ORM (used internally by SQLModel)

## Stack

- Python 3.12+ (uv)
- Docker / Docker Compose

## Theoretical Context

### What SQLModel Is & The Problem It Solves

SQLModel is a library by [Sebastian Ramirez](https://github.com/tiangolo) (the creator of FastAPI) that solves the **model duplication problem** in Python web APIs. In a typical FastAPI + SQLAlchemy stack, you define the same data shape three times:

1. **SQLAlchemy model** -- maps to the database table (using `Column`, `Integer`, `String`, etc.)
2. **Pydantic "create" model** -- validates incoming request data
3. **Pydantic "read" model** -- serializes outgoing response data

These three definitions contain nearly identical fields but use different syntax. When you add a field, you must update all three. This violates DRY and is a constant source of bugs.

SQLModel eliminates this by creating a single base class that is **simultaneously a SQLAlchemy model AND a Pydantic model**. A class like `Hero(SQLModel, table=True)` can be added to a database session, committed, queried -- AND validated, serialized to JSON, and used as a FastAPI response model.

### How `table=True` Works

The `table=True` parameter is the switch between "database table" and "data schema":

- **`class Hero(SQLModel, table=True)`** -- This class maps to a real PostgreSQL table. SQLModel generates a SQLAlchemy `Table` object behind the scenes, registers it in `SQLModel.metadata`, and makes the class compatible with `Session.add()`, `Session.exec(select(Hero))`, etc. Fields become database columns.

- **`class HeroCreate(SQLModel)`** -- Without `table=True`, this is a pure Pydantic model. No database table. Used for request/response validation only. It cannot be added to a session.

Under the hood, SQLModel's metaclass checks for `table=True` and branches:
- If True: creates SQLAlchemy column descriptors, registers the table in MetaData, sets up the ORM mapper
- If False: delegates entirely to Pydantic's model machinery

### The Model Hierarchy Pattern

SQLModel's recommended pattern for API development is to define multiple models per entity:

```
Hero(SQLModel, table=True)    -- The database table. Has ALL fields (id, name, age, team_id, etc.)
HeroCreate(SQLModel)          -- API input for creation. Omits id (auto-generated by DB)
HeroRead(SQLModel)            -- API output. Includes id. Controls what clients see
HeroUpdate(SQLModel)          -- API input for updates. All fields Optional (partial update)
```

This is NOT model duplication -- each model has a distinct purpose and a different field set. The table model has relationships and foreign keys. The create model omits auto-generated fields. The update model makes everything optional.

### Session Lifecycle

A `Session` in SQLAlchemy/SQLModel is a **unit of work** that:
1. Tracks which objects have been added, modified, or deleted
2. Batches changes until `commit()` is called
3. Flushes all changes to the DB in a single transaction on commit
4. Provides an **identity map** (cache): loading the same row twice returns the same Python object

The lifecycle for a typical API request:
```
Session created → objects loaded/modified → commit() → refresh() → Session closed
```

Sessions are NOT thread-safe. In FastAPI, each request gets its own Session via dependency injection (`Depends(get_session)`), ensuring request isolation.

### Relationship Patterns

SQLModel inherits SQLAlchemy's relationship system:

- **Foreign Key (`Field(foreign_key="table.column")`)** -- Creates the actual database constraint. This is what PostgreSQL enforces.
- **Relationship (`Relationship(back_populates="...")`)** -- Creates a Python-side attribute for navigating between related objects. No database column is created.

You need BOTH for a working bidirectional relationship: the foreign key for DB integrity, the Relationship for Python object navigation.

**Loading strategies** (how relationships are fetched from DB):
- **Lazy (default)**: Related objects are loaded when you access the attribute. Risk: N+1 queries.
- **selectinload**: Loads related objects in a second `SELECT ... WHERE id IN (...)` query. Always 2 queries total.
- **joinedload**: Uses a LEFT JOIN. 1 query, but duplicates parent data in the result set.

### Async Support

SQLModel inherits SQLAlchemy 2.0's async capabilities:
- `create_async_engine()` -- uses asyncpg instead of psycopg2
- `AsyncSession` -- async version of Session (all operations are `await`-ed)
- The `select()` syntax is **identical** -- the same query works in both sync and async sessions

The connection URL changes from `postgresql://` to `postgresql+asyncpg://` to select the async driver.

### Comparison with Raw SQLAlchemy

| Aspect | Raw SQLAlchemy 2.0 | SQLModel |
|--------|-------------------|----------|
| **Model definition** | `Base = declarative_base()` + `mapped_column()` | `SQLModel` + `Field()` |
| **Type annotations** | Mapped[int], Mapped[str] | Python-native `int`, `str` |
| **Pydantic integration** | Manual -- separate Pydantic models | Built-in -- models ARE Pydantic |
| **Query syntax** | `select(Hero)` | `select(Hero)` (identical) |
| **Relationships** | `relationship()` | `Relationship()` (same API) |
| **FastAPI integration** | Requires serialization layer | Direct -- models work as response_model |
| **Flexibility** | Full SQLAlchemy power | Slightly limited (no composite keys, limited mapper config) |
| **Learning curve** | Steeper (ORM concepts + Pydantic separately) | Gentler (unified API) |

**What SQLModel simplifies**: model definition, type annotations, Pydantic integration, FastAPI serialization.

**What SQLModel loses**: some advanced SQLAlchemy features (composite primary keys, advanced mapper configurations, custom column types). For most CRUD APIs, these are not needed.

### Ecosystem Context

- **GitHub**: [tiangolo/sqlmodel](https://github.com/tiangolo/sqlmodel) -- 17.6k stars, 9.4M monthly PyPI downloads
- **Used with**: FastAPI (primary target), but works with any framework
- **Alternatives**: SQLAlchemy 2.0 alone, Tortoise ORM (async-first), Peewee (simpler), Django ORM
- **When to choose SQLModel**: FastAPI projects needing CRUD APIs with PostgreSQL/MySQL/SQLite

## Description

Hands-on practice with SQLModel's core features in a FastAPI application. You will build a Heroes/Teams API with full CRUD, relationships, pagination, and async support -- all backed by a PostgreSQL database running in Docker.

### What you will learn

1. **SQLModel model definitions** -- `table=True` vs. plain Pydantic models, `Field()` for columns
2. **Database setup** -- engine creation, `create_all()` for table initialization, session management
3. **CRUD operations** -- create, read (list + single), update (partial), delete using `select()` and `session`
4. **Relationships** -- one-to-many between Team and Hero, `Relationship()` with `back_populates`
5. **FastAPI integration** -- automatic validation, serialization, dependency injection, OpenAPI docs
6. **Read/write model separation** -- HeroCreate vs. HeroRead vs. HeroUpdate patterns
7. **Eager loading** -- `selectinload` to avoid N+1 queries
8. **Async support** -- AsyncEngine + AsyncSession with asyncpg

## Instructions

### Phase 1: Setup & Model Definitions (~15 min)

1. Start PostgreSQL with `docker compose up -d`. Verify it is healthy with `docker compose ps`.
2. Initialize the Python project with `uv sync`.
3. **Exercise (app/models.py -- Team class):** Define the Team table model with id, name (indexed), headquarters, and a `heroes` relationship. This teaches how `table=True` creates a real DB table and how `Relationship()` sets up Python-side navigation without adding a DB column. The `back_populates` parameter makes the relationship bidirectional.
4. **Exercise (app/models.py -- Hero class):** Define the Hero table model with id, name (indexed), secret_name, age (optional), team_id (foreign key), and a `team` relationship. This teaches the distinction between foreign_key (DB constraint) and Relationship (Python convenience), and why foreign keys are Optional when the relationship is optional.

### Phase 2: Database Engine & Sessions (~10 min)

1. **Exercise (app/database.py -- create_engine_and_tables):** Create the SQLModel engine with the PostgreSQL URL and call `create_all()`. This teaches engine creation (connection pooling), `echo=True` for SQL logging, and how `metadata.create_all()` generates DDL from your model classes.
2. **Exercise (app/database.py -- get_session):** Implement the Session generator for FastAPI dependency injection. This teaches the unit-of-work pattern and why each request needs its own Session (thread safety, transaction isolation).

### Phase 3: CRUD Operations (~20 min)

1. **Exercise (app/crud.py -- create_hero):** Implement the add -> commit -> refresh cycle. This teaches the fundamental write pattern in SQLAlchemy/SQLModel and why `refresh()` is needed after `commit()` to get auto-generated fields.
2. **Exercise (app/crud.py -- get_heroes):** Implement paginated listing with `select().offset().limit()`. This teaches SQLModel's query API and offset/limit pagination.
3. **Exercise (app/crud.py -- get_hero_by_id):** Implement single-item fetch with `session.get()`. This teaches the difference between `session.get()` (uses identity map, optimized for PK) vs `select().where()` (always queries).
4. **Exercise (app/crud.py -- update_hero):** Implement partial updates with `model_dump(exclude_unset=True)`. This teaches the critical distinction between "field not sent" and "field set to None" in PATCH requests.
5. **Exercise (app/crud.py -- delete_hero):** Implement delete with fetch-first pattern. This teaches why fetch-then-delete is preferred over raw DELETE (cascade handling, event hooks).

### Phase 4: FastAPI Endpoints & Testing (~20 min)

1. **Exercise (app/api.py -- create_hero_endpoint):** Wire up POST /heroes/ with HeroCreate validation and HeroRead response. This teaches how FastAPI + SQLModel provide automatic request parsing, validation, and response serialization through type annotations.
2. **Exercise (app/api.py -- list_heroes_endpoint):** Wire up GET /heroes/ with offset/limit query params and Query(le=100) validation.
3. **Exercise (app/api.py -- read_hero_endpoint):** Wire up GET /heroes/{hero_id} with 404 handling via HTTPException.
4. Start the server with `uv run uvicorn app.main:app --reload` and test all endpoints:
   - Open http://localhost:8000/docs (Swagger UI -- auto-generated from your models)
   - Create heroes via POST, list them, fetch by ID, update with PATCH, delete
   - Verify SQL logs in the terminal (echo=True shows every query)

### Phase 5: Relationships & Async (~25 min)

1. **Exercise (app/relationships.py -- create_team_with_heroes):** Create a team and heroes in a single transaction. This teaches relationship-based assignment (setting `team=team` instead of `team_id=team.id`), cascade behavior, and transactional integrity.
2. **Exercise (app/relationships.py -- get_team_with_heroes):** Fetch a team with eagerly loaded heroes using `selectinload`. This teaches the N+1 problem and how eager loading solves it.
3. Test the relationships via the interactive Python console or by adding temporary endpoints.
4. Install asyncpg: `uv add asyncpg`
5. **Exercise (app/async_demo.py -- create_async_engine_and_session):** Create an async engine with `create_async_engine()` and initialize tables via `run_sync()`. This teaches how async wraps sync operations and the `postgresql+asyncpg://` URL scheme.
6. **Exercise (app/async_demo.py -- async_create_and_query):** Demonstrate async CRUD with `AsyncSession`. This teaches that the query syntax is identical -- only `await` keywords differ.
7. Run the async demo: `uv run python -m app.async_demo`

## Motivation

- **Most popular FastAPI ORM**: SQLModel is the recommended ORM for FastAPI projects by its author. The FastAPI docs reference it directly.
- **Eliminates model duplication**: A single class serves as DB model + API schema -- the biggest DX improvement over raw SQLAlchemy for CRUD APIs.
- **17.6k GitHub stars, 9.4M monthly downloads**: Widely adopted, battle-tested, growing ecosystem.
- **Bridges SQLAlchemy + Pydantic**: Understanding SQLModel means understanding both underlying libraries -- transferable knowledge.
- **Directly applicable at work**: Any FastAPI + PostgreSQL project benefits from SQLModel's reduced boilerplate.
- **Foundation for 058b**: Understanding SQLModel's abstractions makes it easier to drop down to raw SQLAlchemy 2.0 when needed (practice 058b).

## Commands

All commands run from `practice_058a_sqlmodel_fastapi/`.

### Infrastructure

| Command | Description |
|---------|-------------|
| `docker compose up -d` | Start PostgreSQL 16 container (port 5432) |
| `docker compose ps` | Verify PostgreSQL container is healthy |
| `docker compose down` | Stop and remove PostgreSQL container |
| `docker compose down -v` | Stop container AND delete database volume (fresh start) |
| `docker compose logs -f postgres` | Stream PostgreSQL logs |

### Project Setup

| Command | Description |
|---------|-------------|
| `uv sync` | Install Python dependencies from pyproject.toml |
| `uv add asyncpg` | Install asyncpg driver for Phase 5 async exercises |

### Development Server

| Command | Description |
|---------|-------------|
| `uv run uvicorn app.main:app --reload` | Start FastAPI dev server with hot-reload (port 8000) |
| `uv run uvicorn app.main:app --reload --port 8080` | Start on alternate port 8080 |

### Testing Endpoints

| Command | Description |
|---------|-------------|
| Open `http://localhost:8000/docs` in browser | Swagger UI -- interactive API documentation |
| Open `http://localhost:8000/redoc` in browser | ReDoc -- alternative API documentation |
| `curl -X POST http://localhost:8000/heroes/ -H "Content-Type: application/json" -d '{"name":"Spider-Man","secret_name":"Peter Parker","age":25}'` | Create a hero via curl |
| `curl http://localhost:8000/heroes/` | List all heroes |
| `curl http://localhost:8000/heroes/1` | Get hero by ID |
| `curl -X PATCH http://localhost:8000/heroes/1 -H "Content-Type: application/json" -d '{"age":26}'` | Partial update a hero |
| `curl -X DELETE http://localhost:8000/heroes/1` | Delete a hero |

### Async Demo (Phase 5)

| Command | Description |
|---------|-------------|
| `uv run python -m app.async_demo` | Run the async SQLModel demonstration script |

### Database Access

| Command | Description |
|---------|-------------|
| `docker exec -it sqlmodel-postgres psql -U sqlmodel_user -d sqlmodel_db` | Open psql shell inside the container |
| `\dt` (inside psql) | List all tables |
| `SELECT * FROM hero;` (inside psql) | Query heroes directly in PostgreSQL |
| `SELECT * FROM team;` (inside psql) | Query teams directly in PostgreSQL |

## References

- [SQLModel Official Docs](https://sqlmodel.tiangolo.com/)
- [SQLModel Tutorial -- Define Models](https://sqlmodel.tiangolo.com/tutorial/create-db-and-table/)
- [SQLModel Tutorial -- Relationships](https://sqlmodel.tiangolo.com/tutorial/relationship-attributes/)
- [SQLModel Tutorial -- FastAPI Integration](https://sqlmodel.tiangolo.com/tutorial/fastapi/)
- [SQLModel Tutorial -- Read/Write Models](https://sqlmodel.tiangolo.com/tutorial/fastapi/multiple-models/)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [SQLAlchemy 2.0 Async](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html)
- [SQLModel GitHub](https://github.com/tiangolo/sqlmodel)

## State

`not-started`
